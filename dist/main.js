(()=>{"use strict";const r="@group(0) @binding(0) var screen_sampler : sampler;\r\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) Position : vec4<f32>,\r\n    @location(0) TexCoord : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vs_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fs_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n  return textureSample(color_buffer, screen_sampler, TexCoord);\r\n}";var e=function(r,e,n,t){return new(n||(n=Promise))((function(a,i){function s(r){try{c(t.next(r))}catch(r){i(r)}}function f(r){try{c(t.throw(r))}catch(r){i(r)}}function c(r){var e;r.done?a(r.value):(e=r.value,e instanceof n?e:new n((function(r){r(e)}))).then(s,f)}c((t=t.apply(r,e||[])).next())}))};const n=document.getElementById("gfx-main"),t=new class{constructor(r){this.frameCount=0,this.fractalParams={fractalType:3,iterations:7,foldScale:3,offsetX:2,offsetY:0,offsetZ:5,_pad1:0,_pad2:0},this.render=()=>{this.frameCount++;const r=new Float32Array([this.fractalParams.fractalType,this.fractalParams.iterations,this.fractalParams.foldScale,this.fractalParams.offsetX,this.fractalParams.offsetY,this.fractalParams.offsetZ,this.fractalParams._pad1,this.fractalParams._pad2]);this.device.queue.writeBuffer(this.transformBuffer,0,r);const e=this.device.createCommandEncoder(),n=e.beginComputePass();this.device.queue.writeBuffer(this.timeBuffer,0,new Uint32Array([this.frameCount])),n.setPipeline(this.rayMarchingPipeline),n.setBindGroup(0,this.rayMarchingbindGroup),n.dispatchWorkgroups(Math.ceil(this.canvas.width/8),Math.ceil(this.canvas.height/8),1),n.end();const t=this.context.getCurrentTexture().createView(),a=e.beginRenderPass({colorAttachments:[{view:t,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});a.setPipeline(this.screenPipeline),a.setBindGroup(0,this.screenBindGroup),a.draw(6,1,0,0),a.end(),this.device.queue.submit([e.finish()]),requestAnimationFrame(this.render)},this.canvas=r}updateFractalParam(r,e){this.fractalParams[r]=e,this.resetAccumulation()}refreshLightPositions(){const r=new Float32Array(60);for(let e=0;e<20;++e)r.set([4*Math.random()-2,4*Math.random()-2,8*Math.random()-5],3*e);this.device.queue.writeBuffer(this.sphereBuffer,0,r),this.resetAccumulation()}resetAccumulation(){this.frameCount=0;const r=new Float32Array(this.canvas.width*this.canvas.height*4);this.device.queue.writeBuffer(this.accumulationBuffer,0,r)}initialize(){return e(this,void 0,void 0,(function*(){yield this.setupDevice(),yield this.createAssets(),yield this.makePipeline(),this.render()}))}setupDevice(){return e(this,void 0,void 0,(function*(){var r,e;this.adapter=yield null===(r=navigator.gpu)||void 0===r?void 0:r.requestAdapter(),this.device=yield null===(e=this.adapter)||void 0===e?void 0:e.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}))}createAssets(){return e(this,void 0,void 0,(function*(){this.timeBuffer=this.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.colorBuffer=this.device.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.colorBufferView=this.colorBuffer.createView();const r=this.canvas.width*this.canvas.height*4*4;this.accumulationBuffer=this.device.createBuffer({size:r,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.transformBuffer=this.device.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.sampler=this.device.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1}),this.sphereBuffer=this.device.createBuffer({size:240,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});const e=new Float32Array(60);for(let r=0;r<20;++r)e.set([4*Math.random()-2,4*Math.random()-2,8*Math.random()-5],3*r);this.device.queue.writeBuffer(this.sphereBuffer,0,e)}))}makePipeline(){return e(this,void 0,void 0,(function*(){const e=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]});this.rayMarchingbindGroup=this.device.createBindGroup({layout:e,entries:[{binding:0,resource:this.colorBufferView},{binding:1,resource:{buffer:this.timeBuffer}},{binding:2,resource:{buffer:this.accumulationBuffer}},{binding:3,resource:{buffer:this.transformBuffer}},{binding:4,resource:{buffer:this.sphereBuffer}}]});const n=this.device.createPipelineLayout({bindGroupLayouts:[e]});this.rayMarchingPipeline=this.device.createComputePipeline({layout:n,compute:{module:this.device.createShaderModule({code:"struct MateralInfo{\r\n    albedo: vec3f,\r\n    emissive: vec3f,\r\n    percentSpecular: f32,\r\n    roughness : f32,\r\n    specularColor: vec3f,\r\n}\r\n\r\nstruct HitInfo {\r\n    distance: f32,\r\n    object_id: u32,\r\n    material: MateralInfo,\r\n}\r\n\r\nstruct FractalParams {\r\n    fractalType: f32,\r\n    iterations: f32,\r\n    foldScale: f32,\r\n    offsetX: f32,\r\n    offsetY: f32,\r\n    offsetZ: f32,\r\n    _pad1: f32,\r\n    _pad2: f32,\r\n}\r\n\r\nconst SUN_DIRECTION: vec3f = vec3f(0.3, 1.0, 0.5);\r\nconst SUN_COLOR: vec3f = vec3f(1.0, 0.95, 0.9);\r\nconst SUN_INTENSITY: f32 = 5.0;\r\nconst SUN_ANGULAR_SIZE: f32 = 0.9998;\r\n\r\nconst SPHERE_INTENSITY: f32 = 8.0;\r\n\r\nfn sdBox( p : vec3f, b: vec3f ) -> f32\r\n{\r\n  let q : vec3f = abs(p) - b;\r\n  return length(max(q, vec3f(0.0))) + min(max(q.x,max(q.y,q.z)),0.0);\r\n}\r\n\r\n// Original DE - unchanged\r\nfn de(p_in: vec3f) -> f32 {\r\n    var p = p_in;\r\n    p = vec3f(fract(p.x) - 0.5, p.y, fract(p.z) - 0.5);\r\n    var k = 1.0;\r\n    var s = 0.0;\r\n    \r\n    for (var i = 0; i < 9; i++) {\r\n        s = 2.0 / clamp(dot(p, p), 0.1, 1.0);\r\n        p = abs(p) * s - vec3f(0.5, 3.0, 0.5);\r\n        k *= s;\r\n    }\r\n    \r\n    return length(p) / k - 0.001;\r\n}\r\n\r\n// Original DE1 - unchanged\r\nfn de1(p0: vec3f) -> f32 {\r\n    var p = fract(p0 * 0.5 + 0.5) * 2.0 - 1.0;\r\n    p = abs(p) - 1.0;\r\n    \r\n    if(p.x < p.z) {\r\n        p = p.zxy;\r\n    }\r\n    if(p.y < p.z) {\r\n        p = p.xzy;\r\n    }\r\n    if(p.x < p.y) {\r\n        p = p.yxz;\r\n    }\r\n    \r\n    var s = 1.0;\r\n    for(var i = 0; i < 10; i++) {\r\n        let r2 = 2.0 / clamp(dot(p, p), 0.1, 1.0);\r\n        p = abs(p) * r2 - vec3f(0.6, 0.6, 3.5);\r\n        s *= r2;\r\n    }\r\n    \r\n    return length(p) / s;\r\n}\r\n\r\n// Original DE2 - unchanged\r\nfn de2(p0: vec3f) -> f32 {\r\n    let itr = 10.0;\r\n    let r = 0.1;\r\n    var p = fract((p0 - 1.5) / 3.0) * 3.0 - 1.5;\r\n    p = abs(p) - 1.3;\r\n    \r\n    if(p.x < p.z) {\r\n        p = p.zxy;\r\n    }\r\n    if(p.y < p.z) {\r\n        p = p.xzy;\r\n    }\r\n    if(p.x < p.y) {\r\n        p = p.yxz;\r\n    }\r\n    \r\n    var s = 1.0;\r\n    p -= vec3f(0.5, -0.3, 1.5);\r\n    \r\n    for(var i = 0.0; i < itr; i += 1.0) {\r\n        let r2 = 2.0 / clamp(dot(p, p), 0.1, 1.0);\r\n        p = abs(p) * r2;\r\n        p -= vec3f(0.7, 0.3, 5.5);\r\n        s *= r2;\r\n    }\r\n    \r\n    return length(p.xy) / (s - r);\r\n}\r\n\r\n// DE3 - NOW PARAMETERIZED\r\nfn de3(p0: vec3f) -> f32 {\r\n    var p = fract(p0) - 0.5;\r\n    let O = vec3f(fractalParams.offsetX, fractalParams.offsetY, fractalParams.offsetZ);\r\n    \r\n    let iters = i32(fractalParams.iterations);\r\n    for(var j = 0; j < iters; j++) {\r\n        p = abs(p);\r\n        p = select(p.zyx, p.zxy, p.x < p.y) * fractalParams.foldScale - O;\r\n        if(p.z < -0.5 * O.z) {\r\n            p.z += O.z;\r\n        }\r\n    }\r\n    \r\n    return length(p.xy) / 3e3;\r\n}\r\n\r\n// Original DE4 - unchanged\r\nfn de4(p0: vec3f) -> f32 {\r\n    var p = fract(p0) - 0.5;\r\n    let O = vec3f(2.0, 0.0, 3.0);\r\n    \r\n    for(var j = 0; j < 7; j++) {\r\n        p = abs(p);\r\n        p = select(p.zyx, p.zxy, p.x < p.y) * 3.0 - O;\r\n        if(p.z < -0.5 * O.z) {\r\n            p.z += O.z;\r\n        }\r\n    }\r\n    \r\n    return length(p.xy) / 3e3;\r\n}\r\n\r\nfn map(pos: vec3f) -> HitInfo {\r\n    // Select fractal based on fractalType parameter\r\n    var fractal: f32;\r\n    let ftype = i32(fractalParams.fractalType);\r\n    \r\n    if (ftype == 0) {\r\n        fractal = de(pos);\r\n    } else if (ftype == 1) {\r\n        fractal = de1(pos);\r\n    } else if (ftype == 2) {\r\n        fractal = de2(pos);\r\n    } else if (ftype == 3) {\r\n        fractal = de3(pos);\r\n    } else {\r\n        fractal = de4(pos);\r\n    }\r\n    \r\n    let lightPos: vec3f = vec3f(2.0, 0.0, 0.0);\r\n    let lightSource: f32 = sdBox(pos - lightPos, vec3f(0.01, 0.5, 0.5));\r\n\r\n    var result: HitInfo;\r\n    var minDist = min(fractal, lightSource);\r\n    var closestSphere: u32 = 0u;\r\n    \r\n    for (var i = 0u; i < 20u; i++) {\r\n        let sphereDist = length(pos - spheres[i]) - 0.2;\r\n        if (sphereDist < minDist) {\r\n            minDist = sphereDist;\r\n            closestSphere = i + 3u;\r\n        }\r\n    }\r\n    \r\n    if (minDist == fractal) {\r\n        result.distance = fractal;\r\n        result.object_id = 2u;\r\n        result.material.albedo = vec3f(0.9, 0.9, 0.95);\r\n        result.material.emissive = vec3f(0.0);\r\n        result.material.percentSpecular = 0.2;\r\n        result.material.roughness = 0.3;\r\n        result.material.specularColor = vec3f(1.0);\r\n    }\r\n    else if (minDist == lightSource) {\r\n        result.distance = lightSource;\r\n        result.object_id = 1u;\r\n        result.material.albedo = vec3f(0.0);\r\n        result.material.emissive = vec3f(6.0);\r\n        result.material.percentSpecular = 0.0;\r\n        result.material.roughness = 0.0;\r\n        result.material.specularColor = vec3f(0.0);\r\n    }\r\n    else {\r\n        result.distance = minDist;\r\n        result.object_id = closestSphere;\r\n        result.material.albedo = vec3f(0.0);\r\n        result.material.emissive = vec3f(SPHERE_INTENSITY);\r\n        result.material.percentSpecular = 0.0;\r\n        result.material.roughness = 0.0;\r\n        result.material.specularColor = vec3f(0.0);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfn getDist(rayOrig: vec3f, rayDir: vec3f) -> HitInfo {\r\n    var t : f32 = 0.0;\r\n    var hit: HitInfo;\r\n\r\n    for(var i : i32 = 0; i < 500; i++){\r\n        let pos : vec3f = rayOrig + rayDir * t;\r\n        let hitInfo : HitInfo = map(pos);\r\n        t += hitInfo.distance;\r\n        hit = hitInfo;\r\n        if (hit.distance < 0.001 || t > 100.0) {\r\n            break;\r\n        }\r\n    }\r\n    \r\n    hit.distance = t;\r\n    if (t >= 100.0) {\r\n        hit.object_id = 0u;\r\n    }\r\n    \r\n    return hit;\r\n}\r\n\r\nfn getNormal (p: vec3f) -> vec3f {\r\n    let d = map(p).distance;\r\n    let e = vec2f(0.01, 0.0);\r\n    let n = d - vec3f(\r\n        map(p - e.xyy).distance,\r\n        map(p - e.yxy).distance,\r\n        map(p - e.yyx).distance,\r\n    );\r\n    return normalize(n);\r\n}\r\n\r\nfn getSkyColor(rayDir: vec3f) -> vec3f {\r\n    let skyColor = mix(vec3f(0.5, 0.7, 1.0), vec3f(1.0), rayDir.y * 0.5 + 0.5);\r\n    \r\n    let sunDir = normalize(SUN_DIRECTION);\r\n    let sunDot = dot(rayDir, sunDir);\r\n    \r\n    if (sunDot > SUN_ANGULAR_SIZE) {\r\n        return SUN_COLOR * SUN_INTENSITY;\r\n    }\r\n    \r\n    return skyColor * 0.5;\r\n}\r\n\r\nfn pathTrace (rayStartPos: vec3f, rayStartDir: vec3f) -> vec3f {\r\n    var ret : vec3f = vec3f(0.0, 0.0, 0.0);\r\n    var throughput : vec3f = vec3f(1.0, 1.0, 1.0);\r\n    var rayPos : vec3f = rayStartPos;\r\n    var rayDir : vec3f = rayStartDir;\r\n\r\n    for (var i : u32; i < 8; i++){\r\n        \r\n        var hit: HitInfo = getDist(rayPos, rayDir);\r\n\r\n        if (hit.object_id == 0u){\r\n            ret += throughput * getSkyColor(rayDir);\r\n            break;\r\n        }\r\n        \r\n        let hitPos = rayPos + rayDir * hit.distance;\r\n        let normal = getNormal(hitPos);\r\n\r\n        if(length(hit.material.emissive) > 0.0){\r\n            let emission : vec3f = hit.material.emissive;\r\n            ret += throughput * emission;\r\n            break;\r\n        }\r\n\r\n        let sunDir = normalize(SUN_DIRECTION);\r\n        let shadowRayOrigin = hitPos + normal * 0.01;\r\n        let shadowHit = getDist(shadowRayOrigin, sunDir);\r\n        \r\n        if (shadowHit.object_id == 0u) {\r\n            let NdotL = max(dot(normal, sunDir), 0.0);\r\n            if (NdotL > 0.0) {\r\n                let sunContribution = hit.material.albedo * SUN_COLOR * SUN_INTENSITY * NdotL / 3.14159;\r\n                ret += throughput * sunContribution;\r\n            }\r\n        }\r\n\r\n        var specularChance: f32 = hit.material.percentSpecular;\r\n        \r\n        if(specularChance > 0.0){\r\n            specularChance = FresnelReflectAmount(\r\n                1.0, 1.0, \r\n                normal, rayDir, hit.material.percentSpecular, 1.0);  \r\n        }\r\n        \r\n        let doSpecular : f32 = select(0.0, 1.0, RandomFloat01() < specularChance);\r\n        let rayProbability : f32 = mix(1.0 - specularChance, specularChance, doSpecular);\r\n\r\n        rayPos = hitPos + normal * 0.01;\r\n\r\n        var diffuseRayDir : vec3f = normalize(normal + RandomUnitVector());\r\n        var specularRayDir : vec3f = reflect(rayDir, normal);\r\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hit.material.roughness * hit.material.roughness));\r\n             \r\n        rayDir = mix(diffuseRayDir, specularRayDir, doSpecular);\r\n        throughput *= mix(hit.material.albedo, hit.material.specularColor, doSpecular);\r\n        throughput /= rayProbability;\r\n        \r\n        let p : f32 = max(throughput.r, max(throughput.g, throughput.b));\r\n        if (RandomFloat01() > p){\r\n            break;\r\n        }\r\n\r\n        throughput *= 1.0 / p;\r\n    }\r\n\r\n    return ret;\r\n}\r\n\r\n@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> frameCount : u32;\r\n@group(0) @binding(2) var<storage, read_write> accumulation_buffer: array<vec4f>;\r\n@group(0) @binding(3) var<uniform> fractalParams: FractalParams;\r\n@group(0) @binding(4) var<storage, read> spheres: array<vec3f>;\r\n\r\n@compute @workgroup_size(8, 8, 1)\r\nfn main(@builtin(global_invocation_id) GlobalInvocationID: vec3<u32>) {\r\n    let screen_size: vec2<i32> = vec2<i32>(textureDimensions(color_buffer));\r\n    let screen_pos: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\r\n    \r\n    if (screen_pos.x >= screen_size.x || screen_pos.y >= screen_size.y) {\r\n        return;\r\n    }\r\n\r\n    init_rng(vec2u(GlobalInvocationID.xy), frameCount);\r\n    let jitter : vec2f = vec2f(RandomFloat01(), RandomFloat01()) - 0.5;\r\n    var uv: vec2<f32> = (vec2<f32>(screen_pos) + jitter) / vec2<f32>(screen_size);\r\n    uv = uv * 2.0 - 1.0;\r\n    uv.x *= f32(screen_size.x) / f32(screen_size.y);\r\n    uv.y *= -1.0;\r\n\r\n    let rayOrigin : vec3f = vec3f(0.0, 0.0, -3.0);\r\n    let rayDirection : vec3f = normalize(vec3f(uv.x, uv.y, 1.0));\r\n\r\n    let sample_color = pathTrace(rayOrigin, rayDirection);\r\n\r\n    let buffer_index = u32(screen_pos.y * screen_size.x + screen_pos.x);\r\n\r\n    var accumulated : vec3f;\r\n    if(frameCount == 1u) {\r\n        accumulated = sample_color;\r\n    } else {\r\n        let prev = accumulation_buffer[buffer_index].rgb;\r\n        accumulated = prev + (sample_color - prev) / f32(frameCount);\r\n    }\r\n\r\n    accumulation_buffer[buffer_index] = vec4f(accumulated, 1.0);\r\n    \r\n    accumulated *= 0.5;\r\n    accumulated = ACESFilm(accumulated);\r\n    let display_color = LinearToSRGB(accumulated);\r\n    textureStore(color_buffer, screen_pos, vec4f(display_color, 1.0));\r\n}\r\n\r\nfn LessThan(f : vec3f, value: f32) -> vec3f\r\n{\r\n    return vec3(\r\n        select(0.0f, 1.0f, f.x < value),\r\n        select(0.0f, 1.0f, f.y < value),\r\n        select(0.0f, 1.0f, f.z < value)\r\n    );\r\n}\r\n \r\nfn LinearToSRGB(rgb : vec3f) -> vec3f\r\n{\r\n    let clamped = clamp(rgb, vec3f(0.0f), vec3f(1.0f));\r\n \r\n    return mix(\r\n        pow(clamped, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\r\n        clamped * 12.92f,\r\n        LessThan(clamped, 0.0031308f)\r\n    );\r\n}\r\n \r\nfn SRGBToLinear(rgb: vec3f) -> vec3f\r\n{\r\n    let clamped = clamp(rgb, vec3f(0.0f), vec3f(1.0f));\r\n \r\n    return mix(\r\n        pow(((clamped + 0.055f) / 1.055f), vec3(2.4f)),\r\n        clamped / 12.92f,\r\n        LessThan(clamped, 0.04045f)\r\n    );\r\n}\r\n\r\nfn ACESFilm(x : vec3f) -> vec3f\r\n{\r\n    let a : f32 = 2.51f;\r\n    let b : f32 = 0.03f;\r\n    let c : f32 = 2.43f;\r\n    let d : f32 = 0.59f;\r\n    let e : f32 = 0.14f;\r\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), vec3f(0.0f), vec3f(1.0f));\r\n}\r\n\r\nvar<private> rng_state: u32;\r\n\r\nfn init_rng(pixel: vec2u, frame: u32) {\r\n    var seed = pixel.x + pixel.y * 1920u + frame * 719393u;\r\n    seed = seed * 747796405u + 2891336453u;\r\n    seed = ((seed >> ((seed >> 28u) + 4u)) ^ seed) * 277803737u;\r\n    seed = (seed >> 22u) ^ seed;\r\n    rng_state = seed;\r\n}\r\n\r\nfn RandomFloat01() -> f32 {\r\n    rng_state = rng_state ^ (rng_state << 13u);\r\n    rng_state = rng_state ^ (rng_state >> 17u);\r\n    rng_state = rng_state ^ (rng_state << 5u);\r\n    return f32(rng_state) / 4294967296.0;\r\n}\r\n\r\nfn RandomUnitVector() -> vec3f {\r\n    let z: f32 = RandomFloat01() * 2.0 - 1.0;\r\n    let a: f32 = RandomFloat01() * 6.283;\r\n    let r: f32 = sqrt(1.0 - z * z);\r\n    let x: f32 = r * cos(a);\r\n    let y: f32 = r * sin(a);\r\n    return vec3(x, y, z);\r\n}\r\n\r\nfn FresnelReflectAmount(n1: f32, n2: f32, normal: vec3f, incident: vec3f, f0: f32, f90: f32) -> f32\r\n{\r\n    var r0 = (n1 - n2) / (n1 + n2);\r\n    r0 *= r0;\r\n    var cosX = -dot(normal, incident);\r\n    \r\n    if (n1 > n2)\r\n    {\r\n        let n = n1 / n2;\r\n        let sinT2 = n * n * (1.0 - cosX * cosX);\r\n        if (sinT2 > 1.0)\r\n        {\r\n            return f90;\r\n        }\r\n        cosX = sqrt(1.0 - sinT2);\r\n    }\r\n    \r\n    let x = 1.0 - cosX;\r\n    let ret = r0 + (1.0 - r0) * x * x * x * x * x;\r\n    \r\n    return mix(f0, f90, ret);\r\n}"}),entryPoint:"main"}});const t=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});this.screenBindGroup=this.device.createBindGroup({layout:t,entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.colorBufferView}]});const a=this.device.createPipelineLayout({bindGroupLayouts:[t]});this.screenPipeline=this.device.createRenderPipeline({layout:a,vertex:{module:this.device.createShaderModule({code:r}),entryPoint:"vs_main"},fragment:{module:this.device.createShaderModule({code:r}),entryPoint:"fs_main",targets:[{format:this.format}]},primitive:{topology:"triangle-list"}})}))}}(n);t.initialize(),[{id:"iterations",param:"iterations",decimals:0},{id:"fold-scale",param:"foldScale",decimals:1},{id:"offset-x",param:"offsetX",decimals:1},{id:"offset-y",param:"offsetY",decimals:1},{id:"offset-z",param:"offsetZ",decimals:1}].forEach((r=>{const e=document.getElementById(r.id),n=document.getElementById(`${r.id}-value`);e&&n&&e.addEventListener("input",(e=>{const a=parseFloat(e.target.value);n.textContent=a.toFixed(r.decimals),t.updateFractalParam(r.param,a)}))}));const a=document.getElementById("fractal-select"),i=document.getElementById("fractal-display");a&&i&&a.addEventListener("change",(r=>{const e=parseInt(r.target.value);i.textContent=["DE","DE1","DE2","DE3","DE4"][e],t.updateFractalParam("fractalType",e)}));const s=document.getElementById("refresh-lights");s&&s.addEventListener("click",(()=>{t.refreshLightPositions()}));let f=performance.now(),c=0,o=performance.now();!function r(){const e=performance.now();if(c++,e-o>=500){const r=Math.round(1e3*c/(e-o)),n=((e-o)/c).toFixed(1),a=document.getElementById("fps-display"),i=document.getElementById("frametime-display"),s=document.getElementById("samples-display");a&&(a.textContent=r.toString()),i&&(i.textContent=n+"ms"),s&&(s.textContent=t.frameCount.toString()),c=0,o=e}f=e,requestAnimationFrame(r)}()})();